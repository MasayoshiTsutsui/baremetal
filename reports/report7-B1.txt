05-201020 筒井政成

前問で学んだ、「何型へのポインタなのかによって、+1の意味合いが変わる」という教訓が大いに要求される課題だった。
具体的には、xsdtの36バイト目以降に配置されているother_tablesへのアクセスの時にである。
other_tables配列には、xsdt以下の他のテーブルの先頭アドレスが順次格納されており、物理アドレスは64bitの長さを持つので、unsinged long long 型へのポインタを用意すれば、
そのポインタに１を足したものがそのまま次のテーブルの先頭アドレスの格納場所になっているというわけである。

port mapped io　を行う関数port_in port_outはport_io.sで定義した。
port mapped ioに対応するレジスタのアドレスは、通常の物理アドレスとは異なるアドレス空間にマップされているため、単にアドレスに*をつけてデータを引っ張ってくる、という操作ができない( * は裏でmovとして解釈されているから？)ために、
in,out命令という特殊なロードストア命令を用いなければならないのではないかと考える。
また、この異なるアドレス空間が16bit長のアドレスしか持たないことにも注意が必要だった。unsigned int 型の変数に、アドレスを格納していた理由がこれであろう。

また、今回初めてMIPSのアセンブリ言語に触れて驚いたのが、各命令によって扱われるデータのバイトサイズが、オペランドとなるレジスタに何を選ぶかによって決められている命令があるということである。
例えば、in命令においては、おそらくだが、格納先となるオペランドに３２ビットのeaxレジスタを指定するか、１６ビットのaxレジスタを指定するかで、引っ張ってくるデータサイズが異なるのだろう。
２Aセメスターで扱ったrisc-vのアセンブリ言語は、lw や laなど、命令自体がバイトサイズを規定していたので、その仕様の違いになれるのにだいぶ手こずってしまった。

pm_timer_wait_milisecに関しては、まず受け取ったmsecをカウンタ数"waiting_time_left"に変換して、busy pollingによって得られるカウンタ値の差分を、そこからどんどん引いていき、0を下回ったらloopを抜けられる仕様にした。
だが、すこし悩んだのが、pollingの合間に、PM Timerのカウンタが、上限値をまたいでしまった場合である。
結局、2回のpollingの合間に、カウンタが1周してしまうことはない、という仮定のもとに、たった今pollingで得たカウンタ値が、直前のpollingで得たカウンタ値よりも小さければ、上限値をまたいだものと判断し、
"(カウンタの上限値 - 直前のpolling時のカウンタ値) + たった今のpolling時のカウンタ値 " を、カウンタの差分とした。

