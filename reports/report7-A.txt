05-201020 筒井政成

init_frame_buffer関数は、kernel.cに最初に載っていたサンプルコードとほぼ同じやり方で実装できた。
hardwareinfoに格納されているFrameBuffer構造体へのポインタをこの関数に渡せば、フレームバッファの縦横ピクセル数とフレームバッファの先頭アドレスへのポインタが得られるので、
あとはその先頭から一つずつ色を塗りつぶしていくだけである。（今回は、rgbをすべて０に設定することで黒色に塗った）

putc関数は、font.cのfont配列にのASCII(?)の文字が2bitデータで描画されていることを利用して、それらをshift演算などを用いてその０１描画をそのまま8*8ピクセルの絵として出力するように実装すれば良い。
１文字打ち出すごとにfb_xを8ピクセル分増やしておけば、文字がきちんと連続して出力される。（もちろん、画面の端に到達した場合や、\r \nが入力された場合は、fb_yも８ピクセル分増加させてやる）
画面の右下端に到達した際の挙動は、init_frame_bufferを呼んで画面をフラッシュする仕様にした。

puts,puthは、軽い前処理をして、メインの処理はほぼ全てputcに丸投げするだけである。
前者は、文字列を一文字ずつに分解してputcに渡し、後者は、受け取ったvalueを16進数に変換して、上位桁の値を一つ一つputcに渡すだけである。

また、これは今更すぎる話なのだろうが、"あるポインタの値に1を足す"という行為は、そのポインタが何型のポインタなのかによって全く違うことに注意すべきだと感じた。
今回のinit_frame_bufferやputcの実装で、Pixel構造体へのポインタの値を1ずつ増やすことで、ピクセル一つ一つを順番に移動していったのだが、Pixel構造体は4バイトを占有する構造体なので、Pixel構造体へのポインタを定義すると、そのポインタに1を足すことは、Pixel構造体一つ分ずれたアドレスに書き換えることに対応する、ということである。
よって、ポインタはどうせアドレスを指すものなのだから型は特に気にしなくていい、と考えて、適当な型のポインタを利用してフレームバッファにアクセスすると予期せぬ挙動を産んでしまうであろうことが推察される。

そして、Pixel構造体の中のreservedについてなのだが、ここの値をいじっても出力にはとくにへんかは現れなかったため、単純に4バイトごとにアクセスするcpuのことを考えて、rgbの３バイトを差し引いて残った１バイトに名前をつけただけのものであると推察する。
